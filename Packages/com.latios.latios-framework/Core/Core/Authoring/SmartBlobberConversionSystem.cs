using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Entities.LowLevel.Unsafe;
using Unity.Jobs;

namespace Latios.Authoring
{
    #region Handles
    /// <summary>
    /// A handle to a computed blob to be created by a smart blobber
    /// </summary>
    /// <typeparam name="TBlobType">The top of blob to be created</typeparam>
    public struct SmartBlobberHandle<TBlobType> where TBlobType : unmanaged
    {
        internal ISmartBlobberHandleResolver<TBlobType> m_resolver;
        internal int                                    m_index;

        /// <summary>
        /// Retrieves the blob asset after the smart blobber has run. Throws an exception if called before the smart blobber has run.
        /// </summary>
        /// <returns>The blob asset generated by the smart blobber</returns>
        public BlobAssetReference<TBlobType> Resolve()
        {
            if (m_resolver == null)
                throw new System.InvalidOperationException("This handle has not been initialized.");

            if (!m_resolver.HasProcessed(m_index))
                throw new System.InvalidOperationException(
                    $"The smart blobber of type {m_resolver.GetType().FullName} has not processed the blob yet. Please request the blob generation prior to smart blobber execution such as in DeclareReferencedPrefabs() and do not attempt to resolve the blob until hafter smart blobber execution such as in Convert().");

            return m_resolver.Resolve(m_index);
        }

        /// <summary>
        /// Returns true if this handle was generated by a smart blobber.
        /// </summary>
        public bool IsValid => m_resolver != null;
    }

    /// <summary>
    /// A handle to a computed blob to be created by a smart blobber
    /// </summary>
    public struct SmartBlobberHandleUntyped
    {
        internal ISmartBlobberHandleResolverUntyped m_resolver;
        internal int                                m_index;

        /// <summary>
        /// Retrieves the blob asset after the smart blobber has run. Throws an exception if called before the smart blobber has run.
        /// </summary>
        /// <returns>The blob asset generated by the smart blobber</returns>
        public UnsafeUntypedBlobAssetReference Resolve()
        {
            if (m_resolver == null)
                throw new System.InvalidOperationException("This handle has not been initialized.");

            if (!m_resolver.HasProcessed(m_index))
                throw new System.InvalidOperationException(
                    $"The smart blobber of type {m_resolver.GetType().FullName} has not processed the blob yet. Please request the blob generation prior to smart blobber execution such as in DeclareReferencedPrefabs() and do not attempt to resolve the blob until hafter smart blobber execution such as in Convert().");

            return m_resolver.ResolveUntyped(m_index);
        }

        /// <summary>
        /// Returns true if this handle was generated by a smart blobber.
        /// </summary>
        public bool IsValid => m_resolver != null;
    }
    #endregion
}

namespace Latios.Authoring.Systems
{
    #region BuilderInterfaces
    public interface ISmartBlobberSimpleBuilder<TBlobType> where TBlobType : unmanaged
    {
        public BlobAssetReference<TBlobType> BuildBlob();
    }

    public interface ISmartBlobberContextBuilder<TBlobType, TContextType> where TBlobType : unmanaged where TContextType : struct
    {
        public BlobAssetReference<TBlobType> BuildBlob(int prefilterIndex, int postfilterIndex, ref TContextType context);
    }

    public interface ISmartBlobberHashBuilder<TBlobType, TContextType> where TBlobType : unmanaged where TContextType : struct
    {
        public Hash128 hash(int prefilterIndex, int postfilterIndex, ref TContextType context);
    }
    #endregion

    #region BaseClasses
    /// <summary>
    /// This is the simplest smart blobber type.
    /// </summary>
    /// <typeparam name="TBlobType">The type of blob this smart blobber generates</typeparam>
    /// <typeparam name="TManagedInputType">A struct containing authoring data possibly including managed references</typeparam>
    /// <typeparam name="TUnmanagedConversionType">A struct which contains the necessary unmanaged data and functions for creating a BlobAsset. It's method will be executed in a Burst job.</typeparam>
    [UpdateInGroup(typeof(SmartBlobberConversionGroup))]
    public abstract partial class SmartBlobberConversionSystem<TBlobType, TManagedInputType, TUnmanagedConversionType> : GameObjectConversionSystem
        where TBlobType : unmanaged
        where TManagedInputType : struct
        where TUnmanagedConversionType : unmanaged, ISmartBlobberSimpleBuilder<TBlobType>
    {
        /// <summary>
        /// Add an input to convert to a BlobAsset as well as the unityObject the blob should be associated with. Can only be called before the system is updated or during GatherInputs().
        /// </summary>
        /// <param name="gameObject">The converted GameObject to associate the blob with, throws if null. This object should have an entity associated with it.</param>
        /// <param name="input">Input data which can be used to gather everything needed to generate a blob</param>
        /// <returns>A handle which can be resolved into a BlobAssetReference after the smart blobber runs</returns>
        public SmartBlobberHandle<TBlobType> AddToConvert(UnityEngine.GameObject gameObject, in TManagedInputType input)
        {
            if (m_inputsAreLocked)
            {
                throw new System.InvalidOperationException("You cannot call AddToConvert() during Filter()");
            }

            if (gameObject == null)
            {
                throw new System.ArgumentNullException("unityObject cannot be null");
            }

            int index                                          = m_inputs.Count + m_handleToOutputIndices.Count;
            m_inputs.Add(new InputElement { gameObject         = gameObject, input = input });
            return new SmartBlobberHandle<TBlobType> { m_index = index, m_resolver = this };
        }

        /// <summary>
        /// Add an input to convert to a BlobAsset as well as the unityObject the blob should be associated with. Can only be called before the system is updated or during GatherInputs().
        /// </summary>
        /// <param name="gameObject">The converted GameObject to associate the blob with, throws if null. This object should have an entity associated with it.</param>
        /// <param name="input">Input data which can be used to gather everything needed to generate a blob</param>
        /// <returns>A handle which can be resolved into a BlobAssetReference after the smart blobber runs</returns>
        public SmartBlobberHandleUntyped AddToConvertUntyped(UnityEngine.GameObject gameObject, in TManagedInputType input)
        {
            if (m_inputsAreLocked)
            {
                throw new System.InvalidOperationException("You cannot call AddToConvertUntyped() during Filter()");
            }

            if (gameObject == null)
            {
                throw new System.ArgumentNullException("unityObject cannot be null");
            }

            int index                                      = m_inputs.Count + m_handleToOutputIndices.Count;
            m_inputs.Add(new InputElement { gameObject     = gameObject, input = input });
            return new SmartBlobberHandleUntyped { m_index = index, m_resolver = this };
        }

        /// <summary>
        /// Override this function to collect additional inputs using AddToConvert() and AddToConvertUntyped().
        /// </summary>
        protected virtual void GatherInputs()
        {
        }

        /// <summary>
        /// Generate a converter instance to generate a Blob Asset. You must override this function. Return false to skip the input.
        /// </summary>
        /// <param name="input">The managed input</param>
        /// <param name="gameObject">The GameObject which is being converted.</param>
        /// <param name="converter">The unmanaged data required to generate a Blob Asset. The converter will be executed in a Burst job.</param>
        /// <returns>Returns false if skipped and true if kept.</returns>
        protected abstract bool Filter(in TManagedInputType input, UnityEngine.GameObject gameObject, out TUnmanagedConversionType converter);

        /// <summary>
        /// Override this function to process any handles created during GatherInputs().
        /// </summary>
        protected virtual void FinalizeOutputs()
        {
        }
    }

    /// <summary>
    /// This is a smart blobber type that provides a context object which can use NativeContainers and is accessible by all converters.
    /// </summary>
    /// <typeparam name="TBlobType">The type of blob this smart blobber generates</typeparam>
    /// <typeparam name="TManagedInputType">A struct containing authoring data possibly including managed references</typeparam>
    /// <typeparam name="TUnmanagedConversionType">A struct which contains the necessary unmanaged data and functions for creating a BlobAsset. It's method will be executed in a Burst job.</typeparam>
    /// <typeparam name="TContextType">A struct which may use NativeContainers and is provided to all the converters.</typeparam>
    [UpdateInGroup(typeof(SmartBlobberConversionGroup))]
    public abstract partial class SmartBlobberConversionSystem<TBlobType, TManagedInputType, TUnmanagedConversionType, TContextType> : GameObjectConversionSystem
        where TBlobType : unmanaged
        where TManagedInputType : struct
        where TUnmanagedConversionType : unmanaged, ISmartBlobberContextBuilder<TBlobType, TContextType>
        where TContextType : struct, System.IDisposable
    {
        /// <summary>
        /// Add an input to convert to a BlobAsset as well as the unityObject the blob should be associated with. Can only be called before the system is updated or during GatherInputs().
        /// </summary>
        /// <param name="gameObject">The converted GameObject to associate the blob with, throws if null. This object should have an entity associated with it.</param>
        /// <param name="input">Input data which can be used to gather everything needed to generate a blob</param>
        /// <returns>A handle which can be resolved into a BlobAssetReference after the smart blobber runs</returns>
        public SmartBlobberHandle<TBlobType> AddToConvert(UnityEngine.GameObject gameObject, in TManagedInputType input)
        {
            if (m_inputsAreLocked)
            {
                throw new System.InvalidOperationException("You cannot call AddToConvert() during Filter()");
            }

            if (gameObject == null)
            {
                throw new System.ArgumentNullException("unityObject cannot be null");
            }

            int index                                          = m_inputs.Count + m_handleToOutputIndices.Count;
            m_inputs.Add(new InputElement { gameObject         = gameObject, input = input });
            return new SmartBlobberHandle<TBlobType> { m_index = index, m_resolver = this };
        }

        /// <summary>
        /// Add an input to convert to a BlobAsset as well as the unityObject the blob should be associated with. Can only be called before the system is updated or during GatherInputs().
        /// </summary>
        /// <param name="gameObject">The converted GameObject to associate the blob with, throws if null. This object should have an entity associated with it.</param>
        /// <param name="input">Input data which can be used to gather everything needed to generate a blob</param>
        /// <returns>A handle which can be resolved into a BlobAssetReference after the smart blobber runs</returns>
        public SmartBlobberHandleUntyped AddToConvertUntyped(UnityEngine.GameObject gameObject, in TManagedInputType input)
        {
            if (m_inputsAreLocked)
            {
                throw new System.InvalidOperationException("You cannot call AddToConvertUntyped() during Filter()");
            }

            if (gameObject == null)
            {
                throw new System.ArgumentNullException("unityObject cannot be null");
            }

            int index                                      = m_inputs.Count + m_handleToOutputIndices.Count;
            m_inputs.Add(new InputElement { gameObject     = gameObject, input = input });
            return new SmartBlobberHandleUntyped { m_index = index, m_resolver = this };
        }

        /// <summary>
        /// Override this function to collect additional inputs using AddToConvert() and AddToConvertUntyped().
        /// </summary>
        protected virtual void GatherInputs()
        {
        }

        /// <summary>
        /// Indexer-based mutable access to the <typeparamref name="TManagedInputType"/> array.
        /// </summary>
        public partial struct InputAccess
        {
            public TManagedInputType this[int index]
            {
                get => GetInput(index);
                set => SetInput(index, value);
            }
        }

        /// <summary>
        /// Indexer-based readonly access to the GameObject instances associated with the inputs
        /// </summary>
        public partial struct GameObjectAccess
        {
            public UnityEngine.GameObject this[int index]
            {
                get => GetInput(index);
            }
        }

        /// <summary>
        /// Contains access to inputs and converters during filtering
        /// </summary>
        public struct FilterBlobberData
        {
            /// <summary>
            /// Read-write access to the inputs <typeparamref name="TManagedInputType"/>
            /// </summary>
            public InputAccess input { get; internal set; }
            /// <summary>
            /// Readonly access to the associated UnityEngine.GameObjects being converted
            /// </summary>
            public GameObjectAccess associatedObject { get; internal set; }
            /// <summary>
            /// Read-write access to the converters <typeparamref name="TUnmanagedConversionType"/>. Values are completely uninitialized to begin with.
            /// </summary>
            public NativeArray<TUnmanagedConversionType> converters { get; internal set; }

            public int Count => converters.Length;
        }

        /// <summary>
        /// Setup the converters and context using the inputs. You the <paramref name="inputToFilteredMapping"/> to deduplicate or invalidate inputs.
        /// </summary>
        /// <param name="blobberData">Access to the inputs and converters</param>
        /// <param name="context">Global context object accessible to converters</param>
        /// <param name="inputToFilteredMapping">Set an element to a negative value to skip the corresponding input.
        /// Otherwise, set it to the index of the input to use, which must be equal or lower to the element index.
        /// Examples:
        ///     inputToFilteredMapping[2] = -1; - Discard the third input.
        ///     inputToFilteredMapping[3] = 3; - Use the fourth input as is.
        ///     inputTofilteredMapping[4] = 1; - Treat the fifth input as a duplicate of the second input. The fifth converter will not be executed.
        ///     inputToFilteredMapping[5] = 8; - Invalid. 8 is larger than 5.
        ///     inputToFilteredMapping[6] = 4; inputToFilteredMapping[7] = 6; - Invalid. Cannot mark duplicated of an input that is already marked duplicated.
        ///     </param>
        protected abstract void Filter(FilterBlobberData blobberData, ref TContextType context, NativeArray<int> inputToFilteredMapping);

        /// <summary>
        /// Contains access to inputs and converters after filtering but before the converters have been executed.
        /// </summary>
        public struct PostFilterBlobberData
        {
            /// <summary>
            /// Read-write access to the inputs <typeparamref name="TManagedInputType"/>
            /// </summary>
            public InputAccess input { get; internal set; }
            /// <summary>
            /// Read-write access to the filtered converters <typeparamref name="TUnmanagedConversionType"/>. Values are completely uninitialized to begin with.
            /// </summary>
            public NativeArray<TUnmanagedConversionType> converters { get; internal set; }
            /// <summary>
            /// Readonly access to the mapping from a filtered converter to the original input for manipulating the context object.
            /// </summary>
            public NativeArray<int>.ReadOnly filteredToInputMapping;

            public int Count => converters.Length;
        }

        /// <summary>
        /// Override this function to perform any additional preparation to the filtered list of converters and context. After this, the blob assets will be generated.
        /// </summary>
        /// <param name="blobberData">Access to the filtered subset of inputs and converters</param>
        /// <param name="context">Global context object accessible to converters</param>
        protected virtual void PostFilter(PostFilterBlobberData blobberData, ref TContextType context)
        {
        }

        /// <summary>
        /// Override this function to process any handles created during GatherInputs().
        /// </summary>
        protected virtual void FinalizeOutputs()
        {
        }
    }
    #endregion
}

